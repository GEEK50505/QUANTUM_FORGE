You are a senior software architect and technical documentation specialist. 
Your task is to comprehensively refactor, reorganize, and document the 
QUANTUM_FORGE codebase for a two-developer team building an AI-driven 
scientific computing platform.

CONTEXT:
- Project: Quantum_Forge - Hybrid quantum-classical simulation platform
- Tech Stack: React/TypeScript frontend, Python/FastAPI backend, xTB for quantum chemistry
- Developers: 2 (one junior, learning as building with AI assistance)
- Current State: Multiple updates, some AI-generated code, inconsistent structure
- Problem: Nested redundant folder at /home/greek/Documents/repositories/QUANTUM_FORGE/QUANTUM_FORGE
- Goal: Professional, well-documented, easy-to-understand codebase ready for Q2 2026 MVP

YOUR MISSION:

PHASE 1: DEEP ANALYSIS (Read First, Don't Write Yet)
1. Scan EVERY file and folder in the repository
2. Understand the purpose of each file, function, and component
3. Identify:
   - Redundant or duplicate files
   - Misplaced files (wrong directory)
   - Missing critical files
   - Inconsistent naming conventions
   - Dead code or unused imports
   - The nested QUANTUM_FORGE/QUANTUM_FORGE redundancy

PHASE 2: REORGANIZE STRUCTURE
Follow industry best practices for a full-stack scientific platform:

RECOMMENDED STRUCTURE:
QUANTUM_FORGE/ # Root (remove nested duplicate)
├── README.md # Project overview
├── .gitignore # Git ignore rules
├── docker-compose.yml # Docker orchestration (if exists)
│
├── backend/ # Python FastAPI backend
│ ├── README.md # Backend-specific docs
│ ├── requirements.txt # Python dependencies
│ ├── setup.py # Package setup
│ ├── pyproject.toml # Modern Python config
│ │
│ ├── app/ # Main application code
│ │ ├── init.py
│ │ ├── main.py # FastAPI app entry point
│ │ ├── config.py # Configuration (xTB paths, ports, etc.)
│ │ │
│ │ ├── api/ # API routes
│ │ │ ├── init.py
│ │ │ ├── routes.py # All REST endpoints
│ │ │ ├── dependencies.py # Shared dependencies
│ │ │ └── schemas.py # Pydantic models (request/response)
│ │ │
│ │ ├── core/ # Core business logic
│ │ │ ├── init.py
│ │ │ ├── xtb_runner.py # xTB execution engine
│ │ │ ├── job_manager.py # Job lifecycle management
│ │ │ └── parsers.py # xTB output parsing
│ │ │
│ │ ├── models/ # Data models (if using ORM)
│ │ │ ├── init.py
│ │ │ └── job.py
│ │ │
│ │ ├── utils/ # Utility functions
│ │ │ ├── init.py
│ │ │ ├── logging.py # Logging configuration
│ │ │ ├── validators.py # Input validation
│ │ │ └── formatters.py # Data formatting
│ │ │
│ │ └── tests/ # Backend tests
│ │ ├── init.py
│ │ ├── test_xtb.py
│ │ └── test_api.py
│ │
│ ├── scripts/ # Setup & utility scripts
│ │ ├── setup_environment.sh # Environment setup for Ubuntu/Anaconda
│ │ └── run_dev_server.sh # Start backend dev server
│ │
│ └── logs/ # Log files (gitignored)
│
├── frontend/ # React/TypeScript frontend
│ ├── README.md # Frontend-specific docs
│ ├── package.json # NPM dependencies
│ ├── tsconfig.json # TypeScript config
│ ├── vite.config.ts # Vite bundler config
│ ├── tailwind.config.js # Tailwind CSS config
│ │
│ ├── public/ # Static assets
│ │ └── favicon.ico
│ │
│ ├── src/ # Source code
│ │ ├── main.tsx # React entry point
│ │ ├── App.tsx # Root component
│ │ ├── index.css # Global styles
│ │ │
│ │ ├── api/ # API client
│ │ │ ├── client.ts # Axios instance & API calls
│ │ │ └── types.ts # API type definitions
│ │ │
│ │ ├── components/ # React components
│ │ │ ├── FileUpload.tsx
│ │ │ ├── JobForm.tsx
│ │ │ ├── JobCard.tsx
│ │ │ ├── JobList.tsx
│ │ │ ├── ResultsViewer.tsx
│ │ │ └── MoleculeViewer.tsx
│ │ │
│ │ ├── pages/ # Page components
│ │ │ ├── Dashboard.tsx
│ │ │ └── JobDetails.tsx
│ │ │
│ │ ├── hooks/ # Custom React hooks
│ │ │ └── useJobs.ts
│ │ │
│ │ └── utils/ # Utility functions
│ │ ├── formatters.ts
│ │ └── validators.ts
│ │
│ └── tests/ # Frontend tests
│
├── docs/ # Documentation
│ ├── architecture.md # System architecture
│ ├── api_reference.md # API documentation
│ ├── setup_guide.md # Setup instructions
│ ├── user_guide.md # User documentation
│ └── glossary.md # Technical terms explained
│
├── data/ # Data storage (gitignored)
│ ├── jobs/ # Job submissions and results
│ ├── runs/ # xTB run directories
│ └── examples/ # Example molecules
│ ├── water.xyz
│ └── benzene.xyz
│
├── notebooks/ # Jupyter notebooks
│ └── exploration.ipynb
│
├── deploy/ # Deployment configs (future)
│ ├── docker/
│ └── kubernetes/
│
└── .github/ # GitHub specific
└── workflows/ # CI/CD pipelines (future)

text

EXECUTE REORGANIZATION:
1. Remove the nested /QUANTUM_FORGE/QUANTUM_FORGE redundancy
2. Move all files to proper locations following the structure above
3. Delete duplicate, unused, or temporary files
4. Ensure consistent naming (snake_case for Python, camelCase for TypeScript)
5. Update all import statements to reflect new paths
6. Create missing __init__.py files in Python packages
7. Add .gitignore entries for logs/, data/, node_modules/, __pycache__/, etc.

PHASE 3: COMPREHENSIVE DOCUMENTATION
For EVERY file in the codebase, add detailed inline documentation:

DOCUMENTATION REQUIREMENTS:

For Python Files:
"""
File: backend/app/core/xtb_runner.py

PURPOSE:
This file handles execution of xTB (extended Tight Binding) quantum chemistry
calculations. xTB is a semi-empirical quantum mechanical method used to
calculate molecular properties like energy, geometry, and electronic structure.

TECHNICAL TERMS:

xTB: extended Tight Binding - a fast quantum chemistry method

DFT: Density Functional Theory - a quantum mechanical method (more accurate but slower than xTB)

Geometry optimization: Finding the lowest-energy arrangement of atoms

Hartree: Unit of energy in atomic units (1 Hartree ≈ 27.2 eV)

HOMO-LUMO gap: Energy difference between highest occupied and lowest unoccupied molecular orbitals
(tells us about reactivity and electronic properties)

DEPENDENCIES:

subprocess: For running xTB as external command

json: For parsing xTB output

logging: For tracking execution progress

AUTHOR: Quantum_Forge Team
LAST MODIFIED: 2025-11-08
"""

import subprocess
import json
import logging
from pathlib import Path

Get logger instance for this module
This allows us to track what happens during xTB execution
logger = logging.getLogger(name)

class XTBRunner:
"""
Manages execution of xTB quantum chemistry calculations.

text
This class provides a clean interface to run xTB calculations on molecular
structures and parse the results.

WHAT IT DOES:
1. Takes a molecule structure (XYZ file)
2. Runs xTB to calculate properties (energy, forces, orbitals)
3. Parses and returns results in a structured format

TYPICAL WORKFLOW:
```
runner = XTBRunner(config)
results = runner.execute("water.xyz", "job_123", "normal")
energy = results["energy"]  # Total energy in Hartree
```
"""

def __init__(self, config, logger=None):
    """
    Initialize the xTB runner with configuration.
    
    PARAMETERS:
    - config: XTBConfig object containing paths and settings
    - logger: Optional logger instance (creates one if not provided)
    
    WHAT HAPPENS HERE:
    - Stores configuration for later use
    - Sets up logging to track execution
    - Validates that xTB is installed and accessible
    """
    self.config = config
    self.logger = logger or logging.getLogger(__name__)
    
    # Verify xTB is installed
    # This prevents confusing errors later if xTB is missing
    if not self._verify_xtb_installation():
        raise RuntimeError("xTB not found. Run setup_environment.sh first.")

def execute(self, xyz_file_path, job_id, optimization_level="normal"):
    """
    Execute an xTB calculation on a molecule.
    
    PARAMETERS:
    - xyz_file_path: Path to molecule structure file (XYZ format)
    - job_id: Unique identifier for this calculation
    - optimization_level: "normal" (default) or "tight" (more accurate but slower)
    
    RETURNS:
    Dictionary with:
    - success: True/False if calculation worked
    - energy: Total energy in Hartree
    - homo_lumo_gap: Electronic property in eV
    - results: Full xTB output data
    - error: Error message if failed
    
    WHAT HAPPENS:
    1. Validates input file format
    2. Runs xTB command: "xtb <file> --opt <level> --json"
    3. Captures output and parses JSON results
    4. Logs everything for debugging
    5. Returns structured results
    
    EXAMPLE:
    ```
    result = runner.execute("water.xyz", "job_001", "normal")
    if result["success"]:
        print(f"Energy: {result['energy']} Hartree")
    else:
        print(f"Failed: {result['error']}")
    ```
    """
    # Log start of calculation
    # This appears in logs/quantum_forge.log for tracking
    self.logger.info(f"Starting xTB calculation for job {job_id}")
    
    # ... (rest of method implementation)
text

For TypeScript/React Files:
/**

File: frontend/src/components/JobForm.tsx

PURPOSE:

React component that displays the job submission form.

Allows researchers to upload molecule files and submit xTB calculations.

TECHNICAL TERMS:

Component: Reusable piece of UI in React

State: Data that changes over time (like form inputs)

Props: Data passed from parent to child components

Hook: React function that adds features to components (useState, useEffect)

WHAT THIS DOES:

Shows a form with molecule upload and settings

Validates user input (correct file format, required fields)

Sends data to backend API when submitted

Shows loading state and success/error messages

USED BY: Dashboard.tsx (main page)

AUTHOR: Quantum_Forge Team

LAST MODIFIED: 2025-11-08
*/

import React, { useState } from 'react';
import { submitJob } from '../api/client';
import { FileUpload } from './FileUpload';

/**

JobSubmitForm component

STATE VARIABLES:

moleculeName: Name of the molecule being analyzed

fileContent: Raw XYZ file content uploaded by user

optimizationLevel: "normal" or "tight" calculation accuracy

email: User's email for notifications (optional)

isSubmitting: True when form is being submitted (shows loading spinner)

error: Error message if submission fails

success: Success message with job ID if submission works
*/
export const JobForm: React.FC = () => {
// State management using React hooks
// useState creates a variable that triggers re-render when changed
const [moleculeName, setMoleculeName] = useState('');
const [fileContent, setFileContent] = useState('');
// ... (more state)

/**

Handle form submission

WHAT HAPPENS:

Prevent default form submission (would refresh page)

Validate all required fields are filled

Set loading state (show spinner to user)

Send POST request to backend API

On success: show job ID, clear form

On error: show error message

Clear loading state

ASYNC/AWAIT:

async: This function contains asynchronous operations (API calls)

await: Wait for API call to complete before continuing
*/
const handleSubmit = async (e: React.FormEvent) => {
// Prevent page refresh (default HTML form behavior)
e.preventDefault();

text
// Validate inputs
text
// Check that user provided required data before sending to API
if (!moleculeName || !fileContent) {
  setError('Please provide molecule name and upload a file');
  return;
}

// Set loading state
// This shows a spinner to user so they know something is happening
setIsSubmitting(true);
setError('');  // Clear any previous errors

try {
  // Call API to submit job
  // This sends HTTP POST request to backend
  // Backend will run xTB calculation asynchronously
  const response = await submitJob({
    molecule_name: moleculeName,
    xyz_content: fileContent,
    optimization_level: optimizationLevel,
    email: email || undefined,  // Optional field
  });
  
  // Success! Show job ID to user
  setSuccess(`Job submitted! ID: ${response.job_id}`);
  
  // Reset form for next submission
  // Clear all input fields
  setMoleculeName('');
  setFileContent('');
  // ... (clear other fields)
  
} catch (err) {
  // Something went wrong
  // Display error message to help user understand what failed
  setError('Failed to submit job. Please try again.');
  console.error(err);  // Log full error for debugging
  
} finally {
  // Always runs whether success or error
  // Stop showing loading spinner
  setIsSubmitting(false);
}
};

// Return JSX (HTML-like syntax for React components)
return (
// ... (JSX markup with comments explaining each section)
);
};

text

DOCUMENTATION REQUIREMENTS FOR ALL FILES:
1. **File header**: Purpose, technical terms, dependencies, author, date
2. **Function/method comments**: What it does, parameters, return values, examples
3. **Inline comments**: Explain WHY, not WHAT (code shows what, comments explain why)
4. **Complex sections**: Step-by-step explanation for junior developers
5. **Technical terms**: Define ALL domain-specific terms (xTB, DFT, Hartree, etc.)
6. **External dependencies**: Explain what libraries do and why we use them

GLOSSARY OF TERMS TO DEFINE:
- xTB: extended Tight Binding quantum chemistry method
- DFT: Density Functional Theory
- Hartree: Unit of energy in atomic units
- HOMO-LUMO: Highest Occupied/Lowest Unoccupied Molecular Orbital
- Geometry optimization: Finding lowest-energy atom arrangement
- XYZ file: Standard molecule structure format
- REST API: Web service communication protocol
- FastAPI: Python web framework
- React: JavaScript library for UI
- Async/await: Asynchronous programming pattern
- State management: Tracking data changes in UI
- Middleware: Code that runs between request and response

PHASE 4: QUALITY CHECKS
After reorganization and documentation:
1. Verify all imports work with new paths
2. Ensure no broken references
3. Check that scripts still execute (setup_environment.sh, run_dev_server.sh)
4. Validate that both frontend and backend start successfully
5. Remove any TODO comments that are now addressed
6. Add TODO comments for features still needed

PHASE 5: CREATE MASTER DOCUMENTATION
Create these files if missing:

1. README.md (root) - Updated with new structure
2. backend/README.md - Backend setup and architecture
3. frontend/README.md - Frontend setup and architecture
4. docs/glossary.md - All technical terms defined
5. docs/setup_guide.md - Step-by-step installation
6. docs/api_reference.md - All API endpoints documented
7. CONTRIBUTING.md - Guidelines for developers

DELIVERABLES:
✅ Clean, professional folder structure following best practices
✅ No redundant nested QUANTUM_FORGE folder
✅ Every file comprehensively documented for junior developers
✅ All technical terms defined in context
✅ Consistent naming conventions throughout
✅ All imports updated to new paths
✅ Updated README with new structure
✅ Master glossary of technical terms
✅ No dead code or unused files

OUTPUT FORMAT:
After completion, provide:
1. Summary of changes made
2. List of files moved/deleted/created
3. New directory tree
4. Any issues found and how they were resolved
5. Recommendations for next steps

Begin by analyzing the entire codebase in detail, then proceed with reorganization and documentation.. use the best and most powerful ai model for this task